/**
 *    ||          ____  _ __
 * +------+      / __ )(_) /_______________ _____  ___
 * | 0xBC |     / __  / / __/ ___/ ___/ __ `/_  / / _ \
 * +------+    / /_/ / / /_/ /__/ /  / /_/ / / /_/  __/
 *  ||  ||    /_____/_/\__/\___/_/   \__,_/ /___/\___/
 *
 * Crazyflie control firmware
 *
 * Copyright (C) 2011-2016 Bitcraze AB
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, in version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 * power_distribution_stock.c - Crazyflie stock power distribution code
 */
#define DEBUG_MODULE "PWR_DIST"

#include "power_distribution.h"

#include <string.h>
#include "log.h"
#include "param.h"
#include "num.h"
#include "platform.h"
#include "motors.h"
#include "debug.h"
#include "position_controller.h"
#include <math.h>
#include <stdlib.h>

long long count = 0;

static bool motorSetEnable = false;

static struct {
  uint32_t m1;
  uint32_t m2;
  uint32_t m3;
  uint32_t m4;
} motorPower;

static struct {
  uint16_t m1;
  uint16_t m2;
  uint16_t m3;
  uint16_t m4;
} motorPowerSet;

#ifndef DEFAULT_IDLE_THRUST
#define DEFAULT_IDLE_THRUST 0
#endif

static uint32_t idleThrust = DEFAULT_IDLE_THRUST;

void powerDistributionInit(void)
{
  motorsInit(platformConfigGetMotorMapping());
}

bool powerDistributionTest(void)
{
  bool pass = true;

  pass &= motorsTest();

  return pass;
}

#define limitThrust(VAL) limitUint16(VAL)

void powerStop()
{
  motorsSetRatio(MOTOR_M1, 0);
  motorsSetRatio(MOTOR_M2, 0);
  motorsSetRatio(MOTOR_M3, 0);
  motorsSetRatio(MOTOR_M4, 0);
}

void mylqr(const float x[12], const float xd[12], float u[4])
{
  static const float a[48] = {
      -0.0, 0.0, 0.0, -0.0,
      0.0, 0.0, -0.0, -0.0,
      0.112611584F, 0.112611584F, 0.112611584F, 0.112611584F,
      -0.00732891867F, -0.00732891867F, 0.00732891867F, 0.00732891867F,
      0.00732891867F, -0.00732891867F, -0.00732891867F, 0.00732891867F,
      -0.0674733222F, 0.0674733222F, -0.0674733222F, 0.0674733222F,
      -0.0, 0.0, 0.0, -0.0,
      0.0, 0.0, -0.0, -0.0,
      0.0448630229F, 0.0448630229F, 0.0448630229F, 0.0448630229F,
      -0.00799760409F, -0.00799760409F, 0.00799760409F, 0.00799760409F,
      -0.00799760409F, 0.00799760409F, 0.00799760409F, -0.00799760409F,
      -0.0736295432F, 0.0736295432F, -0.0736295432F, 0.0736295432F};
  float b_x[12];
  float f;
  int i;
  int k;
  /*  Real */
  /*  Sim */
  /*  a = 9.2416e-10; */
  /*  b = 2.9342e-06; */
  /*  c = 0.0023 - u; */
  for (i = 0; i < 12; i++)
  {
    b_x[i] = x[i] - xd[i];
  }
  for (k = 0; k < 4; k++)
  {
    f = 0.0F;
    for (i = 0; i < 12; i++)
    {
      f += a[k + (i << 2)] * b_x[i];
    }
    u[k] = ((float)sqrt(1.06633073E-12F -
                        8.52118E-11F * (0.000548456F - (0.0662175044F - f))) +
            -1.03263289E-6F) /
           4.26059E-11F;
  }
}

void mylqr_pfl(const float x[12], const float xd[12], float u[4])
{
  static const float a[48] = {
      -0.0F, -0.0F, 0, -0.0F, -0.0F, 0,
      -0.0F, -0.0F, -16.683197F, -0.0F, -0.0F, -0.0F,
      -0.0F, -48.0626144F, -0.0F, -0.0F, -0.0F, -0.0F,
      -48.0626144F, -0.0F, -0.0F, -0.0F, -0.0F, -48.0626144F,
      -0.0F, -0.0F, 0, -0.0F, -0.0F, 0,
      -0.0F, -0.0F, -6.64637375F, -0.0F, -0.0F, -0.0F,
      -0.0F, -52.4478188F, -0.0F, -0.0F, -0.0F, -0.0F,
      -52.4478188F, -0.0F, -0.0F, -0.0F, -0.0F, -52.4478188F};
  float xnew[12];
  float J_wb_b[9];
  float Y_idx_1;
  float t15;
  float t16;
  float t18;
  float t2;
  float t20;
  float t21;
  float t23;
  float t26;
  float t28;
  float t3;
  float t31;
  float t31_tmp;
  float t35;
  float t37;
  float t39;
  float t4;
  float t40;
  float t43;
  float t44;
  float t45;
  float t5;
  float t7;
  int i;
  int r3;
  /* COMPJ */
  /*     J_WB_B = COMPJ(IN1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.7.
   */
  /*     08-Dec-2021 14:12:05 */
  t2 = (float)cos(x[3]);
  t3 = (float)cos(x[4]);
  t4 = (float)sin(x[3]);
  Y_idx_1 = (float)sin(x[4]);
  J_wb_b[0] = 1.0F;
  J_wb_b[3] = 0.0F;
  J_wb_b[4] = -t2;
  J_wb_b[5] = t4;
  J_wb_b[6] = Y_idx_1;
  J_wb_b[7] = t3 * t4;
  J_wb_b[8] = t2 * t3;
  for (i = 0; i < 12; i++)
  {
    xnew[i] = x[i];
  }
  i = 1;
  r3 = 2;
  J_wb_b[1] = 0.0F;
  J_wb_b[2] = 0.0F;
  J_wb_b[7] -= 0.0F * Y_idx_1;
  J_wb_b[8] -= 0.0F * Y_idx_1;
  if ((float)fabs(t4) > (float)fabs(-t2))
  {
    i = 2;
    r3 = 1;
  }
  J_wb_b[r3 + 3] /= J_wb_b[i + 3];
  J_wb_b[r3 + 6] -= J_wb_b[r3 + 3] * J_wb_b[i + 6];
  Y_idx_1 = x[i + 9] - x[9] * 0.0F;
  t4 = ((x[r3 + 9] - x[9] * 0.0F) - Y_idx_1 * J_wb_b[r3 + 3]) / J_wb_b[r3 + 6];
  Y_idx_1 -= t4 * J_wb_b[i + 6];
  Y_idx_1 /= J_wb_b[i + 3];
  xnew[9] = (x[9] - t4 * J_wb_b[6]) - Y_idx_1 * 0.0F;
  xnew[10] = Y_idx_1;
  xnew[11] = t4;
  for (i = 0; i < 12; i++)
  {
    xnew[i] -= xd[i];
  }
  for (i = 0; i < 4; i++)
  {
    Y_idx_1 = 0.0F;
    for (r3 = 0; r3 < 12; r3++)
    {
      Y_idx_1 += a[i + (r3 << 2)] * xnew[r3];
    }
    u[i] = Y_idx_1;
  }
  /* COMPTAU */
  /*     TAU = COMPTAU(IN1,IN2) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.7.
   */
  /*     08-Dec-2021 14:12:08 */
  t2 = (float)cos(xnew[3]);
  t3 = (float)cos(xnew[4]);
  t4 = (float)sin(xnew[3]);
  t5 = (float)sin(xnew[4]);
  t7 = xnew[11] * xnew[11];
  t15 = 1.41421354F * u[1] * 0.000107824511F;
  t16 = t3 * 1.41421354F * xnew[10] * xnew[11] * 0.000182030722F;
  t18 = t4 * 1.41421354F * xnew[9] * xnew[10] * 3.36183039E-5F;
  t20 = t2 * 1.41421354F * u[2] * 0.000107824511F;
  t21 = t5 * 1.41421354F * u[3] * 0.000107824511F;
  t23 = t4 * t5 * 1.41421354F * xnew[10] * xnew[11] * 0.000182030722F;
  Y_idx_1 = t2 * t3;
  t26 = Y_idx_1 * 1.41421354F * xnew[9] * xnew[11] * 3.36183039E-5F;
  t37 = t3 * t4;
  t28 = t37 * 1.41421354F * u[3] * 0.000107824511F;
  t31_tmp = t2 * t4;
  t31 = t31_tmp * (xnew[10] * xnew[10]) * 1.41421354F * 7.42062039E-5F;
  t35 = Y_idx_1 * t5 * t7 * 1.41421354F * 7.42062039E-5F;
  t39 = t4 * u[2] * 0.00140386284F;
  t40 = t2 * xnew[9] * xnew[10] * 0.00140386284F;
  t43 = Y_idx_1 * u[3] * 0.00140386284F;
  t44 = t37 * xnew[9] * xnew[11] * 0.00140386284F;
  t45 = t2 * t5 * xnew[10] * xnew[11] * 0.00140386284F;
  Y_idx_1 = 1.0F / t2 * (1.0F / t3);
  t5 = t3 * (t2 * t2) * 1.41421354F * xnew[10] * xnew[11] * 0.000148412408F;
  t37 = t31_tmp * t7 * (t3 * t3) * 1.41421354F * 7.42062039E-5F;
  Y_idx_1 = Y_idx_1 * u[0] * 0.00675F + Y_idx_1 * 0.0662175F;
  t4 = Y_idx_1 + -t15;
  Y_idx_1 = (Y_idx_1 + t15) + t16;
  /*  Real */
  /*  Sim */
  /*  a = 9.2416e-10; */
  /*  b = 2.9342e-06; */
  /*  c = 0.0023 - u; */
  u[0] = 1.06633073E-12F -
         8.52118E-11F *
             (0.000548456F -
              ((((((((((((((((t4 + -t16) + t20) + -t18) + t23) + -t21) + -t26) +
                        -t28) +
                       t31) +
                      t5) +
                     t35) +
                    -t37) +
                   -t39) +
                  -t40) +
                 t44) +
                t45) +
               -t43));
  u[1] = 1.06633073E-12F -
         8.52118E-11F *
             (0.000548456F -
              ((((((((((((((((t4 + t18) + -t16) + -t20) + -t21) + t26) + -t23) +
                        t28) +
                       t31) +
                      t5) +
                     -t35) +
                    -t37) +
                   t39) +
                  t40) +
                 t43) +
                -t44) +
               -t45));
  u[2] =
      1.06633073E-12F -
      8.52118E-11F *
          (0.000548456F -
           (((((((((((((((Y_idx_1 + t18) + t21) + -t20) + t26) + -t23) + t28) +
                    -t31) +
                   -t5) +
                  -t35) +
                 t37) +
                -t39) +
               -t40) +
              t44) +
             t45) +
            -t43));
  u[3] =
      1.06633073E-12F -
      8.52118E-11F *
          (0.000548456F -
           (((((((((((((((Y_idx_1 + t20) + t21) + -t18) + t23) + -t26) + -t28) +
                    -t31) +
                   -t5) +
                  t35) +
                 t37) +
                t39) +
               t40) +
              t43) +
             -t44) +
            -t45));
  u[0] = ((float)sqrt(u[0]) + -1.03263289E-6F) / 4.26059E-11F;
  u[1] = ((float)sqrt(u[1]) + -1.03263289E-6F) / 4.26059E-11F;
  u[2] = ((float)sqrt(u[2]) + -1.03263289E-6F) / 4.26059E-11F;
  u[3] = ((float)sqrt(u[3]) + -1.03263289E-6F) / 4.26059E-11F;
}

void rot_wb(float x[3], const float rpy[3], const bool inv)
{
  float R_wb[9];
  float g_R_wb_tmp[9];
  float h_R_wb_tmp[9];
  float b_R_wb[3];
  float R_wb_tmp;
  float b_R_wb_tmp;
  float c_R_wb_tmp;
  float d_R_wb_tmp;
  float e_R_wb_tmp;
  float f_R_wb_tmp;
  int i;
  int i1;
  int i2;
  R_wb_tmp = (float)sin(rpy[2]);
  b_R_wb_tmp = (float)cos(rpy[2]);
  c_R_wb_tmp = (float)sin(rpy[1]);
  d_R_wb_tmp = (float)cos(rpy[1]);
  e_R_wb_tmp = (float)sin(rpy[0]);
  f_R_wb_tmp = (float)cos(rpy[0]);
  g_R_wb_tmp[0] = b_R_wb_tmp;
  g_R_wb_tmp[3] = -R_wb_tmp;
  g_R_wb_tmp[6] = 0.0F;
  g_R_wb_tmp[1] = R_wb_tmp;
  g_R_wb_tmp[4] = b_R_wb_tmp;
  g_R_wb_tmp[7] = 0.0F;
  R_wb[0] = d_R_wb_tmp;
  R_wb[3] = 0.0F;
  R_wb[6] = -c_R_wb_tmp;
  g_R_wb_tmp[2] = 0.0F;
  R_wb[1] = 0.0F;
  g_R_wb_tmp[5] = 0.0F;
  R_wb[4] = 1.0F;
  g_R_wb_tmp[8] = 1.0F;
  R_wb[7] = 0.0F;
  R_wb[2] = c_R_wb_tmp;
  R_wb[5] = 0.0F;
  R_wb[8] = d_R_wb_tmp;
  for (i = 0; i < 3; i++)
  {
    b_R_wb_tmp = g_R_wb_tmp[i];
    c_R_wb_tmp = g_R_wb_tmp[i + 3];
    i1 = (int)g_R_wb_tmp[i + 6];
    for (i2 = 0; i2 < 3; i2++)
    {
      h_R_wb_tmp[i + 3 * i2] =
          (b_R_wb_tmp * R_wb[3 * i2] + c_R_wb_tmp * R_wb[3 * i2 + 1]) +
          (float)i1 * R_wb[3 * i2 + 2];
    }
  }
  g_R_wb_tmp[0] = 1.0F;
  g_R_wb_tmp[3] = 0.0F;
  g_R_wb_tmp[6] = 0.0F;
  g_R_wb_tmp[1] = 0.0F;
  g_R_wb_tmp[4] = f_R_wb_tmp;
  g_R_wb_tmp[7] = -e_R_wb_tmp;
  g_R_wb_tmp[2] = 0.0F;
  g_R_wb_tmp[5] = e_R_wb_tmp;
  g_R_wb_tmp[8] = f_R_wb_tmp;
  for (i = 0; i < 3; i++)
  {
    b_R_wb_tmp = h_R_wb_tmp[i];
    c_R_wb_tmp = h_R_wb_tmp[i + 3];
    R_wb_tmp = h_R_wb_tmp[i + 6];
    for (i1 = 0; i1 < 3; i1++)
    {
      R_wb[i + 3 * i1] = (b_R_wb_tmp * g_R_wb_tmp[3 * i1] +
                          c_R_wb_tmp * g_R_wb_tmp[3 * i1 + 1]) +
                         R_wb_tmp * g_R_wb_tmp[3 * i1 + 2];
    }
  }
  if (inv)
  {
    for (i = 0; i < 3; i++)
    {
      b_R_wb[i] = (R_wb[i] * x[0] + R_wb[i + 3] * x[1]) + R_wb[i + 6] * x[2];
    }
    x[0] = b_R_wb[0];
    x[1] = b_R_wb[1];
    x[2] = b_R_wb[2];
  }
  else
  {
    for (i = 0; i < 3; i++)
    {
      b_R_wb[i] = (R_wb[3 * i] * x[0] + R_wb[3 * i + 1] * x[1]) +
                  R_wb[3 * i + 2] * x[2];
    }
    x[0] = b_R_wb[0];
    x[1] = b_R_wb[1];
    x[2] = b_R_wb[2];
  }
}

void powerDistribution(const control_t *control, setpoint_t *setpoint, const sensorData_t *sensorData, const state_t *state)
{
  // Runs at 500hz
  count++;

  // States
  float x[12] = {
      state->position.x,
      state->position.y,
      state->position.z,
      state->attitude.roll / 180 * M_PI_F,
      state->attitude.pitch / 180 * M_PI_F,
      state->attitude.yaw / 180 * M_PI_F,
      state->velocity.x,
      state->velocity.y,
      state->velocity.z,
      sensorData->gyro.x / 180 * M_PI_F,
      sensorData->gyro.y / 180 * M_PI_F,
      sensorData->gyro.z / 180 * M_PI_F,
  };

  // Hovering height
  float zd;
  // if (count < 15e3)
  // {
  zd = 0.5;
  // }
  // else
  // {
  //   zd = 0.25F;
  // }
  float dz = zd - x[2];
  if (abs(dz) > 0.05F)
  {
    zd = x[2] + dz / abs(dz) * 0.05F;
  }

  // Desired states
  float xd[12] = {0, 0, zd, 10 / 180 * M_PI_F, 0, 0, 0, 0, 0, 0, 0, 0};

  // Controls
  float u[4];

  mylqr(x, xd, u);
  // mylqr_pfl(x, xd, u);

  for (size_t i = 0; i < 4; i++)
  {
    u[i] = limitThrust(u[i]);
  }

  if (count < 12.5e3 && count > 2.5e3)
  {
    motorsSetRatio(MOTOR_M1, u[0]);
    motorsSetRatio(MOTOR_M2, u[1]);
    motorsSetRatio(MOTOR_M3, u[2]);
    motorsSetRatio(MOTOR_M4, u[3]);

    motorPower.m1 = u[0];
    motorPower.m2 = u[1];
    motorPower.m3 = u[2];
    motorPower.m4 = u[3];
  }
  else
  {
    motorsSetRatio(MOTOR_M1, 0);
    motorsSetRatio(MOTOR_M2, 0);
    motorsSetRatio(MOTOR_M3, 0);
    motorsSetRatio(MOTOR_M4, 0);

    motorPower.m1 = 0;
    motorPower.m2 = 0;
    motorPower.m3 = 0;
    motorPower.m4 = 0;
  }
}

/**
 * Override power distribution to motors.
 */
PARAM_GROUP_START(motorPowerSet)

/**
 * @brief Nonzero to override controller with set values
 */
PARAM_ADD_CORE(PARAM_UINT8, enable, &motorSetEnable)

/**
 * @brief motor power for m1: `0 - UINT16_MAX`
 */
PARAM_ADD_CORE(PARAM_UINT16, m1, &motorPowerSet.m1)

/**
 * @brief motor power for m2: `0 - UINT16_MAX`
 */
PARAM_ADD_CORE(PARAM_UINT16, m2, &motorPowerSet.m2)

/**
 * @brief motor power for m3: `0 - UINT16_MAX`
 */
PARAM_ADD_CORE(PARAM_UINT16, m3, &motorPowerSet.m3)

/**
 * @brief motor power for m4: `0 - UINT16_MAX`
 */
PARAM_ADD_CORE(PARAM_UINT16, m4, &motorPowerSet.m4)

PARAM_GROUP_STOP(motorPowerSet)

/**
 * Power distribution parameters
 */
PARAM_GROUP_START(powerDist)
/**
 * @brief Motor thrust to set at idle (default: 0)
 *
 * This is often needed for brushless motors as
 * it takes time to start up the motor. Then a
 * common value is between 3000 - 6000.
 */
PARAM_ADD_CORE(PARAM_UINT32, idleThrust, &idleThrust)
PARAM_GROUP_STOP(powerDist)

/**
 * Motor output related log variables.
 */
LOG_GROUP_START(motor)
/**
 * @brief Motor power (PWM value) for M1 [0 - UINT16_MAX]
 */
LOG_ADD_CORE(LOG_UINT32, m1, &motorPower.m1)
/**
 * @brief Motor power (PWM value) for M2 [0 - UINT16_MAX]
 */
LOG_ADD_CORE(LOG_UINT32, m2, &motorPower.m2)
/**
 * @brief Motor power (PWM value) for M3 [0 - UINT16_MAX]
 */
LOG_ADD_CORE(LOG_UINT32, m3, &motorPower.m3)
/**
 * @brief Motor power (PWM value) for M4 [0 - UINT16_MAX]
 */
LOG_ADD_CORE(LOG_UINT32, m4, &motorPower.m4)
LOG_GROUP_STOP(motor)
